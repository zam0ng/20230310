// 클로저 : 내부함수에서 외부함수의 변수에 접근할 수 있다.

// function fun(){
//     for (var i = 0; i < 5; i++) {
//         // debugger;
//         setTimeout(() => {
//             console.log(i);
//             // debugger;
//         }, i*1000);
//     }
// }
// fun(); 

// var로하면 출력결과에 5가 5번 뜸 , let으로 하면 0 1 2 3 4 가 뜸
// 이유는 블록 스코프와 함수 스코프 차이
// var는 함수 스코프 ,  let은 블록 스코프
// 자바스크립트 실행 컨택스트 잘 짚고 가야한다.
// var로 선언한 변수는 함수 스코프를 가지고 함수의 어느곳에서든 접근이 가능하다.
// for문도 함수 내부에서 실행되고 for문에 선언한 var 변수는 함수의 어디서든 접근이 가능하다.
// for문 안에서 비동기 처리 함수가 호출되고 for문은 이미 다 종료되고
// 함수가 실행되기 때문에 전부 증가한 5 전부 돌아가고 
// 5로 증가가 이미 되었고 함수스코프로 접근이 가능하기때문에 5가 나온다.

// vscode에서 debugger 키워드를 작성하면 브라우저에서 브레이크 포인트를 설정할 수 있다.
// 개발자모드에서 확인 가능.

// 함수 스코프 : 변수가 선언된 함수에서 유효하다.
//              함수에서 선언된 변수는 함수가 호출되고 종료되면 해제된다.

// 블록 스코프 : 변수가 선언된 블록에서 블록이 종료될 때 사라진다.

// function fun2() {

//     if(true){

//         var a = 45;
//         let b = 50;
//     }
//     console.log(a); // 호출이 됨.
//     console.log(b); // 호출이 안됨.
    
// }
// fun2();

//클로저라는 개념은 함수의 외부 변수와 변수 선언 기준으로 어디까지 변수를 활용할수 있는지 정도 잘 숙지하면된다.

function fun3() {
    let value = ""
    //내부 함수에서 외부함수의 변수를 사용
    function fun4(){
        if(value ==""){
            value = "클로저";
            return value;
        }
    }
    return fun4;
    
}

let closure = fun3();
let a = closure();
console.log(a);

//함수의 변수를 참조해주고 메모리상에 변수가 유지 되도록 한다.
// fun4 함수가 fun3 함수의 value변수를 참조하고 fun4 함수가 실행되면 
// value를 선언 -> fun4 함수는 fun3의 실행 컨텍스트에 생성된 value 값을 변경할 수 있다.
// 자바스크립트가 함수를 생성할때 함수나 변수 선언 위치를 기억해서 함수 반환한 이후에도 참조가 가능하다.